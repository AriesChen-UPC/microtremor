import sys
import warnings
from itertools import combinations
from pathlib import Path
import matplotlib.pyplot as plt
import numpy as np

from iotoolpy.ioGpy import AutocorrTarget
from xcorpy.plotFunc import spac_curve, volume
from xcorpy.baseConfig import cfgpara, cfgresl
from xcorpy.coreFunc import update_init, update_logs, update_prog


def mesh(x0, y0, thresh=0.4):
    """
    Obtain meshed grid from given coordinates

    Parameters
    ----------
    x0: np.ndarray
        1-D array of x coordinates
    y0: np.ndarray
        1-D array of y coordinates
    thresh: float
        Threshold to select grids with mode not lower than percent of maximum mode,
         ranging in (0, 1]

    Returns
    -------
    list[np.ndarray]
        Meshed grid, the 1st element of the list is the x-coordinates, the 2nd is the y-coordinates
    """
    assert len(x0) == len(y0)
    # unique grid values
    x1 = np.unique(x0)
    y1 = np.unique(y0)
    # mode thresh selection
    nx = [sum(x0 == xi) for xi in x1]
    ny = [sum(y0 == yi) for yi in y1]
    xsel = np.where(nx >= max(nx) * thresh)[0]
    ysel = np.where(ny >= max(ny) * thresh)[0]
    return np.meshgrid(x1[xsel], y1[ysel])


def fill(meshgrid, x0, y0, value, rmax=0.5):
    """
    Fill value to the matrix specfied by the meshed grid

    Parameters
    ----------
    meshgrid: list[np.ndarray]
        List of x/y coordinates generated by np.meshgrid
    x0: np.ndarray
        1-D array of x coordinates
    y0: np.ndarray
        1-D array of y coordinates
    value: Any
        value to fill in she shape of meshgrid, sharing the same length of x0 and y0
    rmax: float
        Maximum distance from grid point, ranging in (0,Inf)

    Returns
    -------
    np.ndarray
        Array with filled value, can have multiple None elements
    """
    n = len(value)
    assert len(x0) == len(y0) == n
    dx = meshgrid[0][0, 1:] - meshgrid[0][0, :-1]
    dy = meshgrid[1][1:, 0] - meshgrid[1][:-1, 0]
    dmin = np.min(np.concatenate([dx, dy]))
    outshape = meshgrid[0].shape
    # tmp = np.ones(shape=outshape) * np.nan
    tmp = np.empty(outshape, value.dtype)
    candidate = list()
    for i in range(n):
        r = ((x0[i] - meshgrid[0]) ** 2 + (y0[i] - meshgrid[1]) ** 2) ** 0.5
        if r.min() <= 1e-3:
            tmp[np.unravel_index(r.argmin(), r.shape)] = value[i]
        else:
            candidate.append(i)
    for i in candidate:
        r = ((x0[i] - meshgrid[0]) ** 2 + (y0[i] - meshgrid[1]) ** 2) ** 0.5\
            + ((tmp['location'] != '').astype(float) * 1e-3)
        if r.min() <= rmax * dmin:
            tmp[np.unravel_index(r.argmin(), r.shape)] = value[i]
    return tmp


def cell(inmat):
    """
    Function that transforms gridded array to cells

    Parameters
    -------
    inmat: np.ndarray
        2-D array of any contents

    Returns
    -------
    np.ndarray
        celled array
    """
    assert len(inmat.shape) == 2
    m, n = inmat.shape
    outmat = np.empty(shape=(m - 1, n - 1, 4), dtype=inmat.dtype)
    for i in range(m - 1):
        for k in range(n - 1):
            outmat[i, k] = [inmat[i + 1, k], inmat[i, k], inmat[i, k + 1], inmat[i + 1, k + 1]]
    return outmat


def name(meshgrid, prefix='Grid', digit=0):
    """
    Generate names for meshed grid

    Parameters
    ----------
    meshgrid: list[np.ndarray]
        meshgrid from np.meshgrid
    prefix : object
        Prefix of the name
    digit: int
        Number of digits in the name

    Returns
    -------
    np.ndarray
        Name array that shares the same shape of the meshed grid
    """
    x0, y0 = meshgrid
    m, n = x0.shape
    nmat = np.empty((m - 1, n - 1), '<U20')
    for i in range(m - 1):
        for j in range(n - 1):
            nmat[i, j] = f'{prefix}[{i + 1:0{digit}}-{j + 1:0{digit}}]'
    return nmat


def fromrecd(tab):
    """
    Read record.csv tab

    Parameters
    ----------
    tab: np.recarray
        Read from record.csv

    Returns
    -------
    (list[np.ndarray], list[np.ndarray], np.ndarray)
        Gridded tab, grid names and the associate group name
    """
    groups = np.unique(tab['location'])
    gridname = list()
    gridtab = list()
    for igroup in groups:
        subtab = tab[tab['location'] == igroup]
        ix = subtab['xpoly_n']
        iy = subtab['yradius']
        igrid = mesh(ix, iy)
        ifill = fill(igrid, ix, iy, value=subtab)
        # set empty grid nodes' x/y to np.nan
        for i, j in np.argwhere(ifill['location'] == ''):
            ifill[i, j]['xpoly_n'] = np.nan
            ifill[i, j]['yradius'] = np.nan
        icell = cell(ifill)
        isel = np.zeros(icell.shape[:2], dtype=bool)
        for i in range(icell.shape[0]):
            for j in range(icell.shape[1]):
                isel[i, j] = sum(icell[i, j]['station'] != '') >= 3
        gridname.append(name(igrid)[isel])
        gridtab.append(icell[isel])
    return gridtab, gridname, groups


def plotrecd(gridtab, gridname, origtab=None, suptitle=None, saveto=None):
    """
    Plot grid map from record.csv files

    Parameters
    ----------
    gridtab: list[np.ndarray]
    gridname: list[np.ndarray]
    origtab: np.recarray
    suptitle: str
    saveto: list[str]
    """
    assert len(gridtab) == len(gridname)
    if origtab is not None:
        try:
            origloc = np.unique(origtab['location'])
            assert len(origloc) == len(gridtab)
        except Exception as e:
            warnings.warn(e)
            origtab = None
    # plot each group/location in one figure
    for i in range(len(gridtab)):
        if len(gridtab[i]) == 0:
            continue
        fig, ax = plt.subplots(figsize=(8, 8), tight_layout=True)
        ax.set_title(f'{suptitle} | {gridtab[i][0][0]["location"]}')
        ax.set_aspect(1)
        ax.set_xlabel('x/m')
        ax.set_ylabel('y/m')
        ax.grid()
        # plot all cells
        for j in range(gridtab[i].shape[0]):
            x0 = gridtab[i][j]['xpoly_n'][gridtab[i][j]['station'] != '']
            y0 = gridtab[i][j]['yradius'][gridtab[i][j]['station'] != '']
            dx = x0 - x0.mean()
            dy = y0 - y0.mean()
            x1 = x0.mean() + dx * 0.975
            y1 = y0.mean() + dy * 0.975
            ax.plot(np.append(x1, x1[0]), np.append(y1, y1[0]))
            ax.text(x0.mean(), y0.mean(), gridname[i][j], ha='center')
        # plot stations and their names
        if origtab is not None:
            statab = origtab[origtab['location'] == origloc[i]]
            xsta = statab['xpoly_n']
            ysta = statab['yradius']
            nsta = statab['station']
            ax.scatter(xsta, ysta, marker='^', zorder=5, color='k')
            for k in range(len(statab)):
                ax.text(xsta[k], ysta[k], nsta[k])
        if saveto is not None and len(saveto) == len(gridtab):
            fig.savefig(saveto[i])
        else:
            fig.show()


def prep(proj, resl_root, para_root, update=False):
    """
    Preparing path with given project name

    Parameters
    ----------
    proj: str
        Project name
    resl_root: Path
        Path object to the RESL directory
    para_root: Path
        Path object to the PARA directory
    update: bool
        If the sequence is updated to browser

    Returns
    -------
    (list[Path], np.recarray, str)
        List of path to single-pairs, record.csv tab, project full name
    """
    # path setup
    '''
    if update:
        update_init()
        update_prog('Initialisation', [0, 6], 0, 'Preparing project')
    else:
        print('Preparing project')
    '''
    resl_path = [x for x in resl_root.iterdir() if proj in str(x)]
    para_path = [x for x in para_root.iterdir() if proj in str(x)]
    if len(resl_path) > 1 or len(para_path) > 1:  # TODO: Verify stability
        resl_path = [x for x in resl_root.iterdir() if proj == x.stem]
        para_path = [x for x in para_root.iterdir() if proj == x.stem]
        if len(resl_path) != 1 or len(para_path) != 1:
            '''
            if update:
                update_logs('PythonException', 'error', 'Project name duplicated!')
            '''
            raise Exception('Project name ambiguous!')
    elif len(resl_path) == 0 or len(para_path) == 0:
        '''
        if update:
            update_logs('PythonException', 'Project setup insufficient!')
        '''
        raise Exception('Project setup insufficient!')
    resl_path = resl_path[0]
    para_path = para_path[0]
    assert resl_path.name == para_path.name

    # project setup
    proj_recd = np.recfromcsv(str(list(para_path.glob('*record.csv'))[0]), encoding='UTF-8-sig',
                              dtype=[('location', '<U20'), ('station', '<U20'), ('network', '<U20'),
                                     ('starttime', '<U20'), ('endtime', '<U20'),
                                     ('xpoly_n', '<f8'), ('yradius', '<f8'), ('z', '<f8'), ('note', '<U20')])
    resl_pair = sorted(list(resl_path.rglob('pair')))

    '''
    if update:
        update_prog('Initialisation', [3, 6], 0, 'Loading parameters')
    else:
        print('Project setup complete')
    '''
    return resl_pair, proj_recd, para_path.name


def readpair(name1, name2, ipairpath, filetype=None):
    """
    Read the single-pair cross-correlation result accordingly to the station names

    Parameters
    ----------
    name1: str
    name2: str
    ipairpath: Path
        Path of all single-pairs
    filetype: str
        'gpy' to read gpy output
    Returns
    -------
    (np.recarray, float)
        Data tab, radius
    """
    lst01 = list(ipairpath.glob(f'*gpy*{name1}*.target'))
    lst02 = list(ipairpath.glob(f'*gpy*{name2}*.target'))
    lst11 = list(ipairpath.glob(f'*{name1}*.target'))
    lst12 = list(ipairpath.glob(f'*{name2}*.target'))
    if filetype == 'gpy':
        lst1 = [value for value in lst01 if value not in lst11]
        lst2 = [value for value in lst02 if value not in lst12]
    else:
        lst1 = [value for value in lst11 if value not in lst01]
        lst2 = [value for value in lst12 if value not in lst02]
    lst3 = [value for value in lst1 if value in lst2]
    if len(lst3) != 1:
        warnings.warn('Error: pair not unique!')
    else:
        xcpair = AutocorrTarget(str(lst3[0]), verb=True)
        # TODO: change verbose to False when finished progress reporting
        r = xcpair.AutocorrCurves.AutocorrRing[0]
        tab = xcpair.AutocorrCurves.ModalCurve[0].RealStatisticalPoint
        '''
        freq = tab['x']
        xc = tab['mean'] + tab['imag'] * 1j
        std = tab['stddev']
        '''
        return tab, r


def calc(ipairpath, tablst):
    """
    Calculate grid SPAC from single-pair results

    Parameters
    ----------
    ipairpath: Path
        Path to all single pair results
    tablst: list[np.recarray]
        Processed grid tabs

    Returns
    -------
    (list[np.recarray], list[np.ndarray])
        Calculated tab list and ring radii
    """
    toutlst = list()
    routlst = list()
    for itab in tablst:
        stas = [ista for ista in itab['station'] if ista != '']
        tlst = list()
        rlst = list()
        for n1, n2 in combinations(stas, 2):
            try:
                ttmp, rtmp = readpair(n1, n2, ipairpath, filetype='gpy')
            except TypeError:
                ttmp, rtmp = readpair(n1, n2, ipairpath)
            tlst.append(ttmp)
            rlst.append(rtmp)
        ring = np.unique(rlst)
        tabs = list()
        for i in range(len(ring)):
            ilst = [tlst[j] for j in range(len(tlst)) if rlst[j] == ring[i]]
            tout = np.zeros(shape=tlst[0].shape, dtype=tlst[0].dtype)
            tout['x'] = ilst[0]['x']  # verify all tabs share the same x-axis
            assert all([all(jlst['x'] == tout['x']) for jlst in ilst])
            for attr in ['mean', 'imag', 'stddev']:
                tout[attr] = np.nanmean(np.array([jlst[attr] for jlst in ilst]), 0)
            tout['weight'] = np.array([jlst['weight'] for jlst in ilst]).sum(0)
            tout['valid'] = np.array([jlst['valid'] for jlst in ilst]).all(0)
            tabs.append(tout)
        toutlst.append(tabs)
        routlst.append(ring)
    return toutlst, routlst


def save(toutlst, routlst, namelst, ipairpath, prefix='', plot=False):
    """
    Save grid results to target/csv/plot

    Parameters
    ----------
    toutlst: list[np.recarray]
        Calculated tab list
    routlst: list[np.ndarray]
        Ring radiii matching tab list
    namelst: list[str]
        Name list of the grid
    ipairpath: Path
        Path to all single pair results, this is for determine output directory
    prefix: str
        Prefix to the name
    plot: bool
        If plot is generated
    """
    assert len(toutlst) == len(routlst)
    assert len(toutlst) == len(namelst)
    ioutpath = ipairpath.parent.joinpath('grid')
    if not ioutpath.exists():
        ioutpath.mkdir()
    for i in range(len(toutlst)):
        # prepare data
        assert type(toutlst[i]) == list
        assert len(toutlst[i]) == len(routlst[i])
        if prefix:
            iname = f'{prefix}-{namelst[i]}'
        else:
            iname = namelst[i]
        freq = toutlst[i][0]['x']
        spac = np.array([itab['mean'] for itab in toutlst[i]]) + np.array([itab['imag'] for itab in toutlst[i]]) * 1j
        std = np.array([itab['stddev'] for itab in toutlst[i]])
        rings = routlst[i]
        weight = np.array([itab['weight'] for itab in toutlst[i]])
        # save target file
        tmptarget = AutocorrTarget()
        tmptarget.fromSPAC(freq, spac, std, rings, weight)
        tmptarget.write(ioutpath.joinpath(f'{iname}.target'), verbose=False)
        # save csv file
        for j in range(len(rings)):
            tmphead = 'SPatial Auto-Correlation\n' \
                      'Location: {}\n' \
                      'Ring ID: {:.0f} of {:.0f}\n' \
                      'Ring radius(m): {:.2f}\n' \
                      'Column names:\n' \
                      'Freq, Real, Imag, Std, Up, Low' \
                .format(iname, j + 1, len(rings), rings[j])
            np.savetxt(str(ioutpath.joinpath(f'{iname}[{j + 1}]{rings[j] * 1e2:.0f}cm.csv')),
                       np.vstack([freq, spac[j].real, spac[j].imag, std[j],
                                  spac[j].real + std[j], spac[j].real - std[j]]).T,
                       fmt='%.5f', delimiter=', ', newline='\n', header=tmphead, comments='# ')

        # plot
        if plot:
            spac_curve(freq, spac, spac.real + std, spac.real - std, rings, t0=f'SPAC | {iname}',
                       saveto=ioutpath.joinpath(iname))


if __name__ == "__main__":
    try:
        argv = sys.argv[1]
        print('Input proj: {}'.format(argv))
        pairpath, tab, projname = prep(argv, Path(cfgresl), Path(cfgpara))

        # reading tab
        tablist, namelist, locs = fromrecd(tab)
        # plot grid maps
        plotrecd(tablist, namelist, tab, suptitle='Grid map',
                 saveto=[pairpath[iloc].parent.joinpath(f'gridmap-{locs[iloc]}.png') for iloc in range(len(pairpath))])
        # save results by location
        for iloc in range(len(tablist)):
            itab, ir = calc(pairpath[iloc], tablist[iloc])
            if len(itab) == 0:
                continue
            save(itab, ir, namelist[iloc], pairpath[iloc], prefix=locs[iloc], plot=True)
            rsel = 0
            freq = itab[0][rsel]['x']
            coord = np.array([np.nanmean(tablist[iloc]['xpoly_n'], 1), np.nanmean(tablist[iloc]['yradius'], 1)]).T
            pcoord = np.array(
                [tab[tab['location'] == locs[iloc]]['xpoly_n'], tab[tab['location'] == locs[iloc]]['yradius']]).T
            pname = tab[tab['location'] == locs[iloc]]['station']
            tsel = np.array([igrid[rsel]['mean'] for igrid in itab])
            tsel = tsel[:, freq > 0.5]
            tsel[np.isnan(tsel)] = 1
            volume(coord, tsel, zaxis=freq[freq > 0.5], zlog=True, zname='Frequency/Hz',
                   pcoord=pcoord,  name=pname, cmap=['rainbow'], function='linear',
                   title=f'Grided SPAC @ {locs[iloc]}-{projname}',
                   saveto=pairpath[iloc].parent.joinpath('gridspac.html'))
            volume(coord, tsel - tsel.mean(0), zaxis=freq[freq > 0.5], zlog=True, zname='Frequency/Hz',
                   pcoord=pcoord,  name=pname, cmap=['rdbu'], function='linear',
                   title=f'Grided SPAC-diff @ {locs[iloc]}-{projname}',
                   cmin=[-np.percentile(abs(tsel - tsel.mean(0)), 90)],
                   cmax=[np.percentile(abs(tsel - tsel.mean(0)), 90)],
                   saveto=pairpath[iloc].parent.joinpath('gridspac-diff.html'))

    except Exception as e:
        raise e
